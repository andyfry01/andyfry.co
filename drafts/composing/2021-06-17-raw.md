# Functional Functional React

## 

Now that the hooks API has been out for a couple months and I've gotten a chance to use hooks in my day-to-day job, it's really started to warp and transform my conception of the React component itself. 

Over the years I've tried to limit myself to functional stateless components where I can. But inevitably, the main functionality of any React app is going to be a stateful class component or a state management library like MobX or Redux. These parts of your app are therefore going to be where you spend a lot of your development time and thought. But now that you can have state WITHIN a functional component, I've written nothing but functions for weeks now.  

Maybe it was staring at functions all day instead of classes that did it, maybe learning the new API shifted around some grey matter in an opportune kind of way, but whatever the cause: I practically had a mini-stroke the other day. One of those "Handel seeing the face of God" moments where all of the the sweet sugary JSX was stripped away, and I saw React components for what they really are: not components, but functions! Plain old ordinary functions with a little sprinkling of magic courtesy of the framework. 

It's kind of a stupid epiphany isn't it? Of course they were functions this whole time. What else could they be? But when you *understand* that a component is a function. When you realize that you can *call* a component like you would any function, it opens up an exciting alternate universe full of wacky and strange possibilities. React is a very functional framework to begin with, but once you sacrifice a little bit of the JSX syntax to the gods of FP, it rocks the foundations of your world. 

[Higher order components](https://reactjs.org/docs/higher-order-components.html) – an early method of advanced component composition that has since fallen out of style – become instantly more attractive, and even _easy_ to implement. The very idea of a prop transforms from this esoteric thing with a funny syntax to a plain old function argument. The Context API seems suddenly quaint and limiting when faced with the prospect of sharing state between components via a closure instead. 

I'm calling this concept "Functional Functional React" in my head. Using some of the foundational concepts of functional programming along with functional React components, you can achieve some awesome results with very few lines of code, at the expense of the familiarity and comfort of the typical JSX-oriented approach to writing (and most significantly: _composing_) React components. 

I'm not going to say that this is the best way to write a React app. I make no claims about it being easier or more intuitive or at all preferable to the "traditional" methods, which are numerous and well documented. However, it is *different*, and I think there's real value to seeing things differently. 

Who knows! Maybe you won't adopt this technique fully, but you might find some of it appealing enough to incorporate into a traditional React app. At the very least, I want to pull back the curtain on the React framework a little bit and demystify the all-powerful Component, that we might all better understand what's really going on in our applications. 

## Part one: React component composition

Stop me if you've heard this one before: "React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components." The bedrock, foundational concept of React is composition. Instead of making monolithic classes with generic methods and inheriting from these classes, you're encouraged to think of components as lego blocks: if you need new functionality, combine existing components/lego blocks together to achieve the desired result. 

Implemented well, the elements of your app become these atom-like particles: tiny, simple, purpose-built units of code that can be combined together to form bigger "molecules," which can be combined together with yet *more* molecules, so on and so forth. 

It's the Golden Dream of programming! Orderly stacks of Legos instead of dread-inducing piles of spaghetti. 

But of course, it's much easier to muse about the Golden Dream than to actually realize it in the real world. What does composition look like in practice? Maybe we can start with what composition ISN'T and then work backwards from there. Say we want to build a shopping list, and we need to have both ordered and unordered lists. Here's an implementation:  

```jsx
import React from "react";
import ReactDOM from 'react-dom';

const things = ["Milk", "Eggs", "Cheese"];

const UnorderedList = props => {
  const listItems = props.items.map(listItem => <li>{listItem}</li>);

  return <ul>{listItems}</ul>;
};

const OrderedList = props => {
  const listItems = props.items.map(listItem => <li>{listItem}</li>);

  return <ol>{listItems}</ol>;
};

const NotCompositionExample = () => {
  return (
    <>
      <UnorderedList items={things} />
      <OrderedList items={things} />
    </>
  );
};

ReactDOM.render(<NotCompositionExample />, document.getElementById('root'));
```

It does what we need it to do. If I never had to touch this code again in my whole life, I'd call it done. But things could get sticky fast if you have to maintain or update this in the long-term.

I can see two problems that affect maintainability: duplicated code, and unneccessary wrapper code. 

### Duplicated code
There's duplicated code for building the lists for instance, which doubles the overhead maintenance. Say we wanted to make all of the list items bold, or add checkboxes to them. We'd have to do that in two places, both `UnorderedList` and `OrderedList`. 

Not only that, but we have two separate components just for the different list types, when they only differ in the type of list they render. 

Composing components together allows you to avoid these kinds of patterns. We'll refactor this code later to show you exactly how a compositional approach can improve things, but let's look at the next problem first:

### Unneccessary wrapper code
Remember what I said earlier? React components are "plain old ordinary functions." That applies not *just* to the components *we* write ...

```jsx
// This:
const DivGrimace = () => <div>😬</div>
// Is actually this:
const DivGrimace = () => React.createElement("div", null, "😬")
```

.. but ALSO to the *baked in components* that we use via JSX. They look like their HTML equivalents, but *they* are functions too! [^1]

```jsx
// This: 
<ol>
  <li>World's shortest Todo list</li>
</ol>

// Becomes this: 
React.createElement("ol", 
                    null, 
                    React.createElement("li", 
                                        null, 
                                        "World's shortest Todo list"))

// ... Imagine writing a whole app like that.
```

So why wrap the "`ol` function," whose sole purpose is to add an `ol` element to the DOM, with another function at all [^2]? We don't cook with the papery exterior of an onion do we? What we're really interested in is what's *inside*.

## What's really the issue?

Those problems of duplication and wrapper code all revolve around the idea of things being locked away. The concept of "what's inside" lies at the heart of composing components together. 

What should be inside a component? What should be outside a component? And how do we take the innards out in a way that leaves us less confused and more flexible? That last question is the most important in my opinion. A good programming technique makes your code more accessible and easier to work with. 

First, let's have a look at just one of those components from the previous example: 

```jsx
const OrderedList = props => {
  const listItems = props.items.map(listItem => <li>{listItem}</li>);

  return <ol>{listItems}</ol>;
};
```

If you look closely, you can see that almost the entire implementation for this list is locked away inside the component. All the little pieces that come together to make this thing are enclosed within `OrderedList`'s shiny braces. The list type, the map function which produces the list items, even the *name* that you have to give to the list: `props.items`. This component does absolutely everything for you. The only part of the equation that it *can't* know beforehand is the list: you supply that yourself. As a consequence, that's the only part of the equation that *you can control*. 

Or better stated: it's the only part that you can control without altering the `OrderedList` component itself. 

### The problem with boxes

You can think of these kinds of components like magic boxes. Or maybe they're like a perfectly good iPhone with an old battery. Or an overbearing coworker. Magic boxes, magic consumer products, and micromanagers are huge bottlenecks to progress. Every time you need to get something done, and especially that something is small, you're forced to put in an outsized amount of effort to just get the thing did.

What's in that magic box? No way to tell from the outside, you have to open it up to see. 

Want to swap out the battery in the iPhone? Good chance you're gonna break the phone by prying open the glued-shut casing. 

Need to make a powerpoint for the presentation tomorrow? Well, toss it on the pile and put your feet up, your coworker has to do absolutely everything themselves and won't delegate anything to you. 

## Unlock the box

So! How do we free the contents of the box? How do we use composition to make these brittle, single-use components more flexible and easier to change from the outside? How about like this: 

```jsx
import React from "react";
import ReactDOM from 'react-dom';

const things = ["Milk", "Eggs", "Cheese"];

// xs, as in: "multiple things called X"
const aListOf = xs => xs.map(x => <li>{x}</li>);

const CompositionExample = () => {
  return (
    <>
      <ol>{aListOf(things)}</ol>
      <ul>{aListOf(things)}</ul>
    </>
  );
};

ReactDOM.render(<CompositionExample />, document.getElementById('root'));
```

Let's look at each piece of this individually: 

The first thing is to take the list builder function outside of the container. You don't need the implementation to be locked away inside the magic box, you can just as well build it on the outside and pass it in as a prop to `<ul>` or `<ol>`[^3]:

```jsx
const aListOf = xs => xs.map(x => <li>{x}</li>);
```

On top of  that, we've removed the wrapper function entirely. Instead of enclosing the concept of a `ul` or an `ol` in an unneeded container, why not just use the pre-built function you've got already?

```jsx
<ol>{aListOf(things)}</ol>
```

Much better! We have less code in general, and what remains is:

- **more flexible**: if you need to make changes, you can work on each instance of a list individually instead of mucking around in some big übercomponent.
- **more essential**: the code is a closer, plainer description of the problem being solved. You don't need to peel away layers of code to get to the heart of the thing. It's all plainly visible from the outside.

It all gives more room to breathe. And we're gonna need the room too: now we need some of the lists to contain links. This requires a hairy, monolithic change in the first version of our code:

```jsx
import React from "react";
import ReactDOM from 'react-dom';

// The list is now a list of objects with "text" and "link" properties. 
const things = [
	{text: "Milk", link: "www.milk.com"}, 
	{text: "Eggs", link: "www.eggs.com"}, 
	{text: "Cheese", link: "www.cheese.com"}];

const UnorderedList = props => {
  // We need two things here: a prop which turns on our new link feature, and conditional logic for rendering a list with and without links. 
  // It's a small thing now, but after a few rounds of this kind of customization and tweaking, you'll end up with some seriously hairy code
  const listItems = props.hasLinks 
    ? props.items.map(listItem => <li>{listItem}</li>)
    : props.items.map(listItem => <li><a href={listItem.link}>{listItem.text}</a></li>);

  return <ul>{listItems}</ul>;
};

const OrderedList = props => {
  // Not only that, but we have to double up the code between two different components! It's the exact same stuff!
  const listItems = props.hasLinks 
    ? props.items.map(listItem => <li>{listItem}</li>)
    : props.items.map(listItem => <li><a href={listItem.link}>{listItem.text}</a></li>);

  return <ol>{listItems}</ol>;
};

const NotCompositionExample = () => {
  return (
    <>
      <UnorderedList items={things} hasLinks={true} />
      <OrderedList items={things} />
    </>
  );
};

ReactDOM.render(<NotCompositionExample />, document.getElementById('root'));
```

By contrast, we need just one tiny compositional touch to solve the task with our new code:

```jsx
import React from "react";
import ReactDOM from 'react-dom';

// Same as before, the list is now a list of objects with "text" and "link" properties
const things = [
	{text: "Milk", link: "www.milk.com"}, 
	{text: "Eggs", link: "www.eggs.com"}, 
	{text: "Cheese", link: "www.cheese.com"}];

// Our old list-maker function from before
const aListOf = xs => xs.map(x => <li>{x}</li>);
                             
// One new function, which wraps our list items in an anchor tag first!
const linksOf = xs => xs.map(x => <a href={x.link}>{x.text}</a>);

const CompositionExample = () => {
  // Most significantly: we didn't need to add any new props to anything. No new concepts to fit into our heads, no ever-expanding list of props, no duplication. Just a single new function call.
  const itemsWithLinks = aListOf(linksOf(things));
  const normalItems = aListOf(things);

  return (
    <>
      <ol>{itemsWithLinks}</ol>
      <ol>{normalItems}</ol>
    </>
  );
};

ReactDOM.render(<CompositionExample />, document.getElementById('root'));
```

Pretty cool right? The same thing with less work and more control from the outside. I'd call that a big win!

## In summary

This article touched on code composition from the perspective of React. React has the model of component composition at its core, and the things that those compositions produce – DOM elements – are easy to relate to. We're not producing esoteric things like objects or arrays[^2]; we're producing links and lists and images. You can inspect it with the browser. What your code produces is (usually) visual and plain to see, and that makes it very relatable.

The easiest way to add composition techniques to a component is taking what's on the inside and putting it on the outside. Code that's locked away on the inside of a component is hard to change from the outside, and creates friction when requirements change. Code that's "built" or "assembled" on the outside, on the other hand, is easier to customize after the fact. This makes your code more robust, easier to maintain, and easier to understand. 

But there's more to life than React and the DOM! How do we apply these techniques to vanilla JavaScript? Not only that, but I didn't _really_ show you every facet of the composition diamond either. There's more to it than "take stuff from the inside and put it on the outside," and it can solve different kinds of problems than the ones we've seen in the examples we've seen so far. 

In the next article, we'll focus on code composition with vanilla JavaScript, and we'll get a little closer to the heart of what composition is. If you understood how to do composition in a React context, but haven't tried it for non-React code, then you'll be pleasantly surprised at how much easier this makes your vanilla JS programming! 

Even if you didn't grok everything fully, that's ok. Seeing things from many different angles makes it easier to form connections between concepts and bridge the gap to new understanding. Maybe the above examples will become more clear to you after we explore the fundamentals more closely in the following article. 

And hey, even if you already know this stuff backwards and forwards, you might still learn something new :) 

See you then!



## Part two: vanilla function composition

If you could follow along with the previous post, congratulations! You understand function composition. Or at least you understand function composition as viewed through the lens of React. But what was going on that whole time, really? We put a couple lego bricks together in the manner prescribed to us by the React docs, but what's going on beneath the framework to make this possible? 

There is WAY more to function composition than just assembling React components, and there is WAY more to be gained from function composition than is apparent from the picture of composition that React gives us. You get a very specific picture of it with React: function composition as a means to create and modify the DOM. 

There's more to life than the DOM though, how do we bridge the gap and apply composition to more general programming tasks?

Once you get there, you realize that composition is a powerful tool. Once I understood it, I felt instantly elevated above the inscrutable labyrinth of day-to-day programming drudgery. Before, I felt like every problem was right up against my nose, and that I was just writing the same old bespoke code for the same old problems. Feeling like there's some kind of pattern behind it all, but unable to push the problems away so I could see the patterns within them.[^3] 

Composition can give you wings to rise above all of that. Just don't fly too close to the sun 😉.

## Vanilla JS Composition Techniques

All that being said, let's start down the road to learning how to do vanilla JS function composition. We'll take the same approach as before. In this article, we'll start with a code example that doesn't use composition, and highlight some specific problems that happen when code isn't composable. 

### Part one: back to school

It always has to be basic math with these things, doesn't it? 

```js
const add = (x, y) => x + y

add(10, 5);  // -> 15
```

Nothing too surprising going on there, right? Just a function that takes two arguments and adds them together.

And ... uh, there's a problem with this? How could you possibly improve on this code? Why would you do it differently? 

If you're feeling a little skeptical at this point, I could hardly blame you. Basic math is the most universal, relatable tool we have to explain a lot of programming concepts, but the scale of a basic math example is so small as to seem ridiculous. 

Indulge me for a moment and trust that we can solve many bigger, harier problems with the techniques that we'll employ on this contrived and silly example. To discover those techniques, let's start by asking a few weird questions of this adder function:

### Weird question 1: what if we have to add the same number to a lot of different numbers?

What if we have a big pile of fives that we have to add to a big pile of other numbers? Easy! We just call it with that same number over and over again right? 

```js
const add = (x, y) => x + y

add(5, 5)  // -> 10
add(5, 12) // -> 17 
add(5, 4)  // -> 8
add(5, 18) // -> wait a minute ... 5 + 4 isn't 8!
add(5, 6)  // -> 11
```

This works, but as all dutiful programmers know, this code is not very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). Imagine if all of this code was split between different modules, or if we had a set of 1000 numbers to add to five instead of just a handful. It would be really tedious to change later down the road. Modern IDE tooling makes it easy-ish to refactor this stuff, and therefore makes it easy to write this kind of code without incurring a very high productivity penalty.

But as Ben Kenobi might put it: we have elegant weapons from a more civilized age to solve these kinds of problems. You might be able to refactor this stuff with IDE tools, but no tool can save you from the mental efforts of just _reading_ all of that repetitious code. 

More on that later, on to our second weird question:

### Weird question 2: what if we want to add a bunch of numbers together, one after the other?

This is a twist on the previous example. All of those numbers we were trying to derive were one-offs, being added up into separate unrelated sums, but NOW we need to add a bunch of different numbers to the SAME number:

```js
// We need to add this
28

// To these these: 
[6, 42, 12]

// Using only this
const add = (x, y) => x + y
```

And now we walk the tortuous path that this `add` API has laid for us. Here's one awful way to do it:

```js
const thirtyFour = add(28, 6)
const seventySix = add(thirtyFour, 42)
const eightyEight = add(seventySix, 12)
```

I bet you've encountered less silly but equally annoying exampes of this in your day-to-day work. Real-world math gives us a simple, terse method to solve the problem: `28 + 6 + 42 + 12 = 88`. But real-world programming languages often don't have easy ways to make equivalent "sequential calculations" on things that aren't numbers. Or even if they do, they aren't among the common practices of the language. 

And so we save everything in variables, and we rapidly discover one of the reasons why this is true:

> There are only two hard things in Computer Science: cache invalidation and naming things.
> \- Phil Karlton

*Why* is it hard to name things? You run out of good names really quickly! Especially when you don't have techniques to stem the endless flood of things-that-need-naming. 

Now for the third and final weird question for today:

### Weird question 3: what if we don't know one of the numbers beforehand?

Well ... uh, let's find out:

```js
const add = (x, y) => x + y;

// Fair enough
add(5, anotherNumber) // -> ReferenceError: anotherNumber is not defined

// Makes sense
add(5, undefined) // -> NaN

// Wat 
add(5, null) // -> 5 

// ... let's just ignore that last one ok?
```

In the tidy domain of pure math, of course, this doesn't happen. You either know all of the information up front, or you've got the means within your equations to fill in the blanks for what you don't know yet [^ 3]. In this uncomfortable, non-deterministic dreamscape that we call reality, we're constantly lacking and seeking all kinds of information:

- "How much time has elapsed since that thing happened?" 
- "Which user is logged in right now?" 
- "Is my API server even running?" 

So we need a way to account for information that we don't know yet. 

Things get interesting if you look at the problem from the other end: what if we DO know one of the numbers beforehand? What about the definitive, baked-in stuff that doesn't change. What if we focus on that? This is stuff like: 

- "How high can the player jump in this game?"
- "How long should we wait until trying that API call again?"
- "What is the airspeed of an unladden swallow?"

Now that's interesting information. It's easier for us to focus on what we DON'T yet know if we definitively bake in all of the things that we DO know beforehand and WON'T change during the lifetime of a program. This is an important consideration: if you can clearly express what won't change, you can spend more time focusing on what will. 

### Solving these problems without function composition [^ 4].

Now that we've explored the sticky edges and shortcomings of our adder function, how do we change it? How do we turn it into a better, more refined tool? Well, as with most journeys, there's an awkward middle part before you get to your destination.

Of course, we've been able to solve all of those issues from the previous section this whole time. There are some obvious beginner-level techniques waiting in the wings. Even still, they all have their downsides. By exploring those downsides, we'll discover a little piece of the function composition solution to these problems.

#### Beginner solution 1: adding many numbers to the same number

How do you do this without repeating code? With loops of course!

```js
const add = (x, y) => x + y

const numbers = [5, 12, 4, 18, 16]
const addedNumbers = []

numbers.forEach(num => addedNumbers.push(add(5, num)))
// -> [10, 17, 9, 23, 21]
```

But loops and especially array pushes introduce a new problem: **mutability**. Simply put: you're changing that `addedNumbers` array each time you loop through `numbers`. The seemingly innocent act of changing the value of a variable can create massive headaches down the line. If you don't believe me, consider that [there are](https://elm-lang.org) [entire](https://clojure.org/) [languages](https://www.rust-lang.org/) which revolve around the idea of immutabily, and [most of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) [the latest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) [language features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) of JavaScript are immutable in nature. 

Mutability is impossible to completely avoid. All programs change *something*: a row in a database, a pixel on a screen, the number of rounds in your blaster pistol. A completely immutable program would be nothing but a peaceful, silent statement of facts. There are domains of human activity that are content with such changeless things, but commercial software development ain't one of them.

Even still, mutability is good to avoid when you can. And you can!

#### Beginner solution 2: adding numbers to each other sequentially

You could do the "save every computation in a variable" thing demonstrated above, but saving absolutely everything in a variable has drawbacks. It rapidly drains your [namespace](https://en.wikipedia.org/wiki/Namespace) of all of its simple and expressive words. It's like [slash-and-burn farming](https://en.wikipedia.org/wiki/Slash-and-burn): cheap and easy in the short term, but utterly ruinous in the long term. 

Thankfully, we have the Matroyshka doll technique! This relies on passing functions *directly to other functions*. Functions are [first-class citizens](https://en.wikipedia.org/wiki/First-class_citizen) in JS, which means they can be passed as arguments, just like variables:

```js
const add = (x, y) => x + y

// It works one level deep: 
add(1, add(2, 3)) // -> 6

// Or many levels deep:
add(28, add(6, add(42, 12))) // -> 88
```

This is fine in limited contexts. I do it all the time. But I'm sure you can see the limitations right away. What if we had ten numbers instead of four? 

```js
const add = (x, y) => x + y;

add(2, add(3, add(5, add(7, add(11, add(13, add(17, add(19, add(23, 29)))))))))
// -> 129
```

No justification needed for how awful this is. No IDE could save you from *this*.

And yet, you may be surprised to hear that this very pattern is *exactly* what function composition ultimately boils down to! 

But how? Read on.

#### Beginner solution 3: adding a known number to another unknown number

How about we wrap it in a function? Functions exist for this kind of thing after all: their very purpose is to give us a framework for supplying as-yet-unknown information to a set of computations enclosed within the function itself: 

```js
// What is "it"? We don't know yet ...
const epicFunction = it => console.log(it, " (yeah yeah yeah)")

// ... but we do now:
epicFunction("You want it all but you can't have it") 
// -> You want it all but you can't have it (yeah yeah yeah)"
epicFunction("It's in your face but you can't grab it") 
// -> "It's in your face but you can't grab it (yeah yeah yeah)"
```

And so it goes with our beloved adder machine:

```js
const add = (x, y) => x + y

// Our as yet unknown value ...
const addToFive = x => add(5, x)

// Is now here!
addToFive(5);  // -> 10
addToFive(12); // -> 17 
addToFive(4);  // -> 9
```

So what's the problem here? It's subtle, and just about impossible to see or describe without finally revealing this damn function composition thing I keep alluding to. So let's get on with it: 



### Solving these problems with function composition

What is the answer to all of this? One word: curry.

No, not that Curry. 

IMAGE OF TIM CURRY

Or that one.

IMAGE OF STEPHEN CURRY

That Curry. 

Or the technique named for him anyway. In short, currying is a method by which we can: 

- Avoid mutability
- Get the benefits of variables and sequential calculations without the drawbacks. 
- Save information within a function 

What does it look like? When it comes to JS syntax, it's a tiny but profound shuffling of characters: 

```js
// From writing it like this:
const add = (x, y) => x + y
// And calling it like this: 
const result = add(1, 2) // -> 3

// To writing it like this:
const add = x => y => x + y
// And calling it like this: 
const addOneTo = add(1)
const result = addOneTo(2) // -> 3
```

*Weird*, right? [Implicit arrow function returns](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#comparing_traditional_functions_to_arrow_functions) make this kind of code nice and tidy to write, but it can be confusing to read if you're unfamiliar with currying or if you don't use arrow functions much. Here it is again written with traditional function syntax: 

```js
// Same thing with explicit return statements and the function keyword:
const add = function(x) {
  return function(y) {
    return x + y
  }
}
```

The main takeaway is that we aren't returning a value. Or at least we aren't returning one straight away. On the first function call, we are actually returning a **function**. On the "second call" of the function, we're supplying the final value, and *that* gives us our result:

```js
const add = x => y => x + y
// The first time we call add, it returns a function. 
// We're naming it "addOneTo" to remind us of what is "stored" in the function
// You might know this concept as a closure, "storing" or "saving" is an easy way to think about closures
const addOneTo = add(1)

// If we could magically unravel addOneTo, it would look like this: 
const addOneTo = y => 1 + y

// Now, the second time we call it, we're calling the final function
// This final function call produces the value 3
const result = addOneTo(2) // -> 3
```

This might seem excessive, weird, pointless, or perhaps all three. In the small, it does indeed seem silly, but let's revisit those three problems from the previous post, and explore how currying (and a related concept, piping) can help us. Again, it will enable us to write code that: 

- avoids the pitfalls of mutability
- is easier to read
- frees up variables names in our namespace

We've walked a long path so far, from its beginnings at the problems we're trying to solve, through the middle part of the easiest solutions to those problems, and we're finally ready walk the last steps and discover the compositional solutions! Let's talk about them one-by-one: 

### Composition solution 1:  adding many numbers to the same number

The first attempt of the problem looks like this:

```js
const add = (x, y) => x + y;

add(5, 5);  // -> 10
add(5, 12); // -> 17 
add(5, 4);  // -> 8
add(5, 18); // -> wait a minute ... 5 + 4 isn't 8!
add(5, 6);  // -> 11
```

The problem with this approach was that it isn't [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). Lots of hard-coded 5's in there. What if we need that to be 6 some day? Or 4? Let's pretend we're talking about hundreds of function calls split between many modules and not five function calls in a single file. It would be a lot of work to change all of them.

How does currying help us with this? Remember, when you curry a function, what you're really doing is saving values within it. 

```js
const add = x => y => x + y;
const adder = add(5)
```

Now that 5 is locked away inside the `adder` function, all we need to do is supply it with the second number: 

```js
adder(5);  // -> 10
adder(12); // -> 17 
adder(4);  // -> 9
adder(18); // -> 23
adder(6);  // -> 11
```

Crucially, if we need to change that first number, we only need to update it in a *single place*: that initial function definition: 

```js
const add = x => y => x + y;
// Change it once
const adder = add(6)

// And everything else can remain as it was, but produce new output: 
adder(5);  // -> 11
adder(12); // -> 18 
adder(4);  // -> 10
adder(18); // -> 24
adder(6);  // -> 12
```

And voila! Your work is done. No error-prone find and replace, no digging through Typescript interfaces, no wacky IDE plugins. Just a bit of refinement in how we define our functions. 

### Composition solution 2: adding numbers to each other sequentially

First, a review of the problem we're trying to solve: 

```js
const add = (x, y) => x + y;

add(2, add(3, add(5, add(7, add(11, add(13, add(17, add(19, add(23, 29)))))))))
// -> 129
```

Nasty. But remember what we said previously? 

> "And yet, you may be surprised to hear that this very pattern is *exactly* what function composition ultimately boils down to! "

There's nothing fundamentally "wrong" with this so far as the computer is concerned. The problem isn't really the *technique* of nesting function calls deeply. It's the *nastiness*. The *form* of the code, not the *function*. The clothes it's wearing, not what it does.  

If we had a different way to *express* these deeply nested function calls, we'd have an easier time writing and reading the code. 

And we do! Isn't the above the same as this commonly-agreed "good way" of adding a bunch of numbers?

```js
2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29
```

The exact same result with half the character count. Is there a way we can dress up our nested functions in "mathier" clothes so we can make them easier to write and read? 

For that, we have to introduce one more function: `pipe`. Here it is. Don't panic: 

```js
const pipe = (...functions) => first => functions.reduceRight((x, func) => func(x), first)
```

Woah. Intense right? If you don't understand that at first glance, don't worry, it took me about a year before I *really* understood what it's actually doing. But you can use it even without understanding it. 

Until that undestanding comes, here's a written explaination of how it behaves: 

1. You pass a list of functions you want to run in a sequence, one after the other (the `...functions` argument)
2. After "loading up" the list of functions, you fire the whole thing off with a seed value (the `firstValue` argument)
3. Finally, the function runs that first value successively through all of the functions you supplied previously, ultimately delivering a final value at the end of the process (the `(x, func) => func(x)` callback in the reducer)

What does it look like in practice? Something like this: 

```js
// Remember, this function is curried now:
const add = x => y => x + y

// Instead of deeply nesting our function calls, we can pipe them instead.
// Remember, when you see `add(2)` or `add(3)`, what lies beneath the surface is this: 
/// const add(2) = (y => 2 + y)
const addEmUp = pipe(
  add(2),
	add(3),
	add(5),
  add(7),
	add(11),
	add(13),
	add(17),
	add(19),
	add(23))

// With our pipe loaded up with a sequence of calculations, all we need to do now is supply the first value to kick off the chain:
const result = addEmUp(29) // -> 129 
```

One important thing to focus on is that the result is *no different* than what we had before. Piping `29` through each of those functions, one after another, is exactly equivalent to nesting all of those uncurried `add` functions, one inside the other. 

The *form*. The form is what's changed. What `pipe` allows us to do is take syntax that is *hard* to read, write, and change, and turn it into code that is *easy* to read, write, and change. 


### Composition solution 3: adding a known number to another unknown number

First, a reminder of what we're trying to improve on: 

```js
const add = (x, y) => x + y

// Our as yet unknown value ...
const addToFive = x => add(5, x)

// Is now here!
addToFive(5)  // -> 10
addToFive(12) // -> 17 
addToFive(4)  // -> 9
```

What if I told you we had already solved it? And that currying gave us the solution for free? 

```js
// compare this uncomposed, uncurried version: 
const add = (x, y) => x + y
const addToFive = x => add(5, x)

addToFive(6) // -> 11

// to the curried and composed version:
const add = x => y => x + y
const addToFive = add(5)

addToFive(6) // -> 11
```

It might not seem like the curried version of this is doing ... well, anything of value. We get the exact same function on the other end, it's roughly the same amount of code. What's the point? 

For that, we need one new function, a currying helper. 

#### Brief diversion: currying helper

What problem does a currying helper solve? You can manually curry in JS by stringing together arrow functions, but this has some annoying limitations. There may be situations where you **do** want to call the function as though it **weren't** curried. Currying and composition are great, but not all function calls are alike. Sometimes composition is useful for expressing a complicated problem succinctly, but sometimes it just gets in the way of quick understanding. 

Sometimes you just need to add two damn numbers together: 

```js
// If you call this
const add = x => y => x + y
// Like this:
add(1, 2)
// JavaScript thinks you've tried to do something like this: 
const add = (1, 2) => y => 1 + y
// And gives you this in return: 
// y => 1 + y
```

When you call a manually curried function with "normal" function syntax, JavaScript thinks that you've supplied an "extra argument" to the first function in the chain. Seeing as the first function in the chain only one argument `x`, it grabs `1` as the first argument, ignores the number `2` entirely, and leaves you scratching your head. 

You *could* technically call the function like this: 

```js
const add = x => y => x + y
add(1)(2) // -> 3
```

But that's one step too far into the weird end of the pool. We're trying to gain expressivity, not confuse ourselves.

And so we turn to our friend `curry`, which brings us the best of both worlds: 

```js
const curry = func => {
  return innerCurry = (...args) => {
    if (args.length >= func.length) {
      return func(...args);
    }
    return (...args2) => innerCurry([...args, ...args2]);
  }
}
```

If you didn't understand that, don't worry. I don't really get it either. [There](https://github.com/lodash/lodash/blob/4.17.11/lodash.js#L10200) [are](https://github.com/dominictarr/curry/blob/master/curry.js) [many](https://github.com/ramda/ramda/blob/master/source/curry.js) libraries out there which implement some form of this function. They all work in various ways, but the only thing you really need to know is that they enable you to do this: 

```js
const adder = curry((a, b, c) => a + b + c)
// Call it any way you like: 
adder(1, 2, 3) // -> 6
adder(1)(2)(3) // -> 6

const addThreeTo = adder(3)
addThreeTo(1, 2) // -> 6
```


#### Built-in value saver

Now that we've got that out of the way, we can work on an example which will demonstrate the value of currying from the perspective of storing our known values. Here's a more involved three-argument demo function: 

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)

// Demo invokation with all arguments: 
const myDentist = namer("Dr.", "Pasha", "DDS")
// -> Dr. Pasha DDS
```

Let's say that we have a doctor, but we don't know his name:

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)

// No currying
const doctor = (name, suffix) => namer("Dr.", name, suffix)

// With currying: 
const doctor = namer("Dr.")

// Both functions return this string: 
doctor("Pasha", "DDS") // -> Dr. Pasha DDS
```

Lots more code to write when you've got more than a couple arguments huh? Now let's try this: we've got a couple doctors. We know their names, now we need a unique suffix for each. Some schools award you a DDS degree, but some call it a DMD.

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)
const doctor = (name, suffix) => namer("Dr.", name, suffix)
const doctorPasha = suffix => doctor("Pasha", suffix)
const doctorStrange = suffix => doctor("Strange", suffix)

const pashaNYU = doctorPasha("DDS") // -> Dr. Pasha DDS
const strangeYale = doctorStrange("DMD") // -> Dr. Strange DMD
```

Compare this with a curried implementation: 

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)
const doctor = namer("Dr.")
const doctorPasha = doctor("Pasha")
const doctorStrange = doctor("Strange")

const pashaNYU = doctorPasha("DDS") // -> Dr. Pasha DDS
const strangeYale = doctorStrange("DMD") // -> Dr. Strange DMD
```

With currying, the mechanism for saving values is *built in* to the function itself! Why spend all of those lines of code spinning up a brand new function for enclosing new variables when you've got one built in already? 

Not only that, but you only need to look at one function to understand the composed implementation of those functions: `namer`. The uncurried versions of `doctor`, `doctorPasha` and `doctorStrange` all implement the same API as `namer`, but what if they didn't? If they did something unique *before* calling `namer` – maybe uppercasing or lowercasing their inputs, or trimming whitespace characters from the string – you'd have to go digging through each bespoke function to discover where it was happening: 

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)

// Whoops, doctor has uppercased the "name" argument on us unexpectedly:
const doctor = (name, suffix) => namer("Dr.", name.toUpperCase(), suffix)
const doctorPasha = suffix => doctor("Pasha", suffix)

// Hey ... this is not the string that namer's API promised me!
const pashaNYU = doctorPasha("DDS") // -> Dr. PASHA DDS
```

The curried version, on the other hand, would require you to capitalize the string *before* passing it in. Just like we said in the first article of the series: composition encourages you to take the unique qualities of your code, pull them out from within your inner functions, and state them front and center:

```js
const namer = curry((prefix, name, suffix) => `${prefix} ${name} ${suffix}`)
const doctor = namer("Dr.")
// name.toUpperCase() isn't buried in a custom function anymore, it's right there on the outside
const doctorPasha = doctor("Pasha".toUpperCase())
const doctorStrange = doctor("Strange")

const pashaNYU = doctorPasha("DDS") // -> Dr. Pasha DDS
const strangeYale = doctorStrange("DMD") // -> Dr. Strange DMD
```

Now we don't have to go digging for custom code *or* write our own closures! Nice. 

## Summary

In this chonker of an article



[^1]: Haven't seen React.createElement before? Check out the [React documentation](https://reactjs.org/docs/react-without-jsx.html) for a nice explanation of what it is 👍
[^2]: This concept is known as "layers of indirection" if you'd like to read more about it: https://lispcast.com/is-your-layer-of-indirection-actually-useful/
[^2]: I know, I know, that actually _is_ what we're building. Indulge me in the argument for a moment.
[^3]: For more on that idea, I will direct you to this wonderful MIT lecture series from Bartozs Milewski https://youtu.be/I8LbkfSSR58?t=1280
[^3]: Remember: anything passed within the braces of JSX is passed as `props.children`
[^4]: Cf. this wonderful video on the pure world of math vs. the fuzzy, wiggly world in which we actually live: https://www.youtube.com/watch?v=_ADi5JlFf1E
[^5]: Well, if you really wanted to split hairs, you could say that some of these strategies are a form of function composition, but I don't think most functional programmers would agree.

